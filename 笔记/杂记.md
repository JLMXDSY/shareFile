

### 5、块儿级作用域

- 块儿级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式不再必要了

    ```js
    // 匿名立即执行函数表达式
    (function(){
        var tmp = 0;
    }())
    // 块儿级作用域写法
    {
        let tmp = 0;
    }
    ```

- 函数尽量不要在块儿级作用域内声明，如需可使用函数表达式
  
> 参考 https://es6.ruanyifeng.com/#docs/let

- ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。
- 顶层对象和全局变量的关系
  
    > var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性

#### 6、作用域链和闭包

闭包主要是子函数操作了父函数的变量，父函数把子函数返回出来了。

#### 7、构造函数、工厂模式、原型链、类
- 构造函数
    ```js
    // a)构造函数首字母大写以区分不同函数 b)构造函数用new关键字调用 c)内部用this关键字来构造属性和方法
    function Person(name,age) {
        this.name = name,
        this.age = age,
        this.say =function(){console.log('hello')}
    }
    // 构造函数执行流程：在堆内存新建一个对象 -> 将this指向新建对象 -> 执行构造代码 -> 返回新建对像(this)
    var p1 = new Person('张三','18');
    ```

#### 8、修改对象的属性
- 属性描述符(descriptor)
    > 对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。 

    - 数据描述符和存取描述符均具有以下可选键值(默认值是在使用Object.defineProperty()定义属性的情况下)：
        + configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。
        + enumerable 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。
    - 数据描述符同时具有以下可选键值
        + value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
        + writable 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。
    - 存取描述符同时具有以下可选键值
        + get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。默认为 undefined。
        + set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。默认为 undefined。
    
- Object.defineProperty()
    ```js
    // 定义
    Object.defineProperty(obj,key,descriptor) 
    直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
    // 注意
    默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。
    因为：
    1、configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改。
    2、当writable属性设置为false时，该属性被称为“不可写”
    3、当然如果是用直接赋值的方式（例如obj.a=2）添加的属性，那么属性描述符的特性默认都为true，就可以修改了
    ```
#### 9、JavaScript 按照如下规则将变量转换成布尔类型
> 1、false、0、空字符串（""）、NaN、null 和 undefined 被转换为 false

> 2、所有其他值被转换为 true

# HTML

## html5、html4、xml 区别

```
HTML4是为了适应pc时代产生的
HTML5是为了适应移动互联网时代产生的
HTML5增加了canvas 元素（绘画）、video 元素（媒体回放）、audio 元素、新的特殊内容元素（article、footer、header、nav、section）、表单控件（calendar、date、time、email、url、search)
```
## [h5\css3](https://blog.csdn.net/chandoudeyuyi/article/details/69206236)
# CSS

## [清楚浮动的方法](https://www.cnblogs.com/nxl0908/p/7245460.html)

## 渐变

- 线性渐变 background: linear-gradient(direction, color-stop1, color-stop2, ...);
- 径向渐变 background: radial-gradient(center, shape size, start-color, ..., last-color);
- 角度线性 background: linear-gradient(angle, color-stop1, color-stop2);

```css
background: linear-gradient(to left right, red, back, blue);
background: radial-gradient(center, shape size, start-color, ..., last-color);
background: linear-gradient(180de, color-stop1, rgba(0, 0, 0, 0.5));
```

# JS

## [ES6](https://www.cnblogs.com/libin-1/p/6716470.html)
- ES6模块化
可以在浏览器运行，但是不能在nodejs运行
```js
// 导入
  // obj是默认导入，后面是按需导入，合写必须默认在按需前面
import obj,{variable1,variable2} from './xxx.js'
// 导出
  // 默认导出只能导出1个
export default {ad:address, tm:riqi}
  // 按需导出可以导出多个
export var variable1=100;
export var variable2=200;
```
- CommonJS模块化
可以在nodejs运行，但不能在浏览器运行（如果在浏览器运行使用改版commonjs AMD、CMD）

## switch

- break 再循环中的作用是 跳出一个循环或者结束一个循环
- 看到 continue 立即结束本次循环，继续执行下一次循环

## [session cookie](https://www.cnblogs.com/endlessdream/p/4699273.html)



## [webStorage](https://www.cnblogs.com/pengc/p/8714475.html)

webStorage目前只能存储字符串类型，存的时候需要编译，数字会自动转为字符串，取值时要注意转换。

`localStorage`存储的数据是永久性的，除非Web应用刻意删除存储的数据，否则数据将一直保留在用户的电脑上，永不过期。`localStorage`的作用域是限定在文档源级别的,文档源是通过协议、主机名以及端口三者来确定的。

- 同源的文档间共享同样的localStorage数据（不论该源的脚本是否真正地访问localStorage）。它们可以互相读取对方的数据，甚至可以覆盖对方的数据。但是，非同源的文档间互相都不能读取或者覆盖对方的数据（即使它们运行的脚本是来自同一台第三方服务器也不行）

- localStorage的作用域也受浏览器供应商限制。如果你使用Firefox访问站点，那么下次用另一个浏览器（比如，Chrome）再次访问的时候，那么本次是无法获取上次存储的数据的。

 `sessionStorage` 属性允许你访问一个，对应当前源的 session [`Storage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage) 对象。存储在 `sessionStorage` 里面的数据在页面会话结束时会被清除。

- sessionStorage的作用域还被限定在窗口中。如果同源的文档渲染在不同的浏览器标签页中，那么它们互相之间拥有的是各自的sessionStorage数据，无法共享；一个标签页中的脚本是无法读取或者覆盖由另一个标签页脚本写入的数据，哪怕这两个标签页渲染的是同一个页面，运行的是同一个脚本也不行。
- 这里提到的基于窗口作用域的sessionStorage指的窗口只是顶级窗口。如果一个浏览器标签页包含两个<iframe>元素，它们所包含的文档是同源的，那么这两者之间是可以共享sessionStorage的。

- 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。
- **在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，**这点和 session cookies 的运行方式不同。
- 打开多个相同的URL的Tabs页面，会创建各自的`sessionStorage`。
- 关闭对应浏览器tab，会清除对应的`sessionStorage`。

## [axios](https://www.kancloud.cn/yunye/axios/234845)

## [promise](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000)
### [promise原理](file:///Volumes/EAGET%E5%BF%86%E6%8D%B7/%E5%89%8D%E7%AB%AF/%E9%BB%91%E9%A9%AC/vue/%E7%AC%AC4%E5%A4%A9/%E7%AC%AC4%E5%A4%A9/Code/03-promise.js)
“承诺将来会执行”的对象在 JavaScript 中称为 Promise 对象
在 JavaScript 的世界中，所有代码都是单线程执行的。
由于这个“缺陷”，导致 JavaScript 的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现

```js
function test(resolve, reject) {
  var timeOut = Math.random() * 2;
  console.log("set timeout to: " + timeOut + " seconds.");
  setTimeout(function() {
    if (timeOut < 1) {
      console.log("call resolve()...");
      resolve("200 OK");
    } else {
      console.log("call reject()...");
      reject("timeout in " + timeOut + " seconds.");
    }
  }, timeOut * 1000);
}
var p1 = new Promise(test);
var p2 = p1.then(function(result) {
  console.log("成功：" + result);
});
var p3 = p2.catch(function(reason) {
  console.log("失败：" + reason);
});
```

## [AJAX 同步异步](https://blog.csdn.net/xiegongmiao/article/details/78217386)

我们在发送 AJAX 请求后，还需要继续处理服务器的响应结果，如果这时我们使用异步请求模式同时未将结果的处理交由另一个 JS 函数进行处理。这时就有可能发生这种情况：异步请求的响应还没有到达，函数已经执行完了 return 语句了，这时将导致 return 的结果为空字符串。

## axios拦截器
```js
var instance = axios.create({
    baseURL:'http://127.0.0.1:3006'
})
Vue.prototype.$http=instance
var vm=new Vue({
    created(){
        this.$http.interceptors.request.use(config=>{
            this.showloading=true
            return config;
        },function(error){
            return Promise.reject(error);
        });
        this.$http.interceptors.response.use(response=>{
            this.showloading=false
            return response;
        },function(error){
            return Promise.reject(error);
        });
    },
    el:'#app',
    data:{
        showloading:false
    },
    methods:{
        async request_get(){
            const{data:res} = await this.$http.get('/api/get',{params:{info:'加载效果'}})
        }
    }
})
```

## [js 中的同步和异步](https://www.cnblogs.com/c3gen/p/6170504.html)

## [jsonp为什么不是ajax](https://blog.csdn.net/qq_41696819/article/details/81384230)

## 内置对象
### [Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)

### [String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)
#### String.prototype.padEnd()
```js
// 会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。
str.padEnd(targetLength [, padString])
'abc'.padEnd(10, "foo");   // "abcfoofoof"
```
#### String.prototype.padStart()
```js
// 用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。
str.padStart(targetLength [, padString])
'abc'.padStart(6,"123465"); // "123abc"

```

### [Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)

### [Math](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)

### [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)

## [json和js对象互相转换](https://blog.csdn.net/lzslzya/article/details/72457824)
## [数据类型判断](https://www.cnblogs.com/zt123123/p/7623409.html)

## [跨域请求资源的方法](https://www.cnblogs.com/minigrasshopper/p/8573519.html)

# [web前端性能优化](https://blog.csdn.net/fuzhongmin05/article/details/69397581)

### [hasOwnProperty()](https://blog.csdn.net/qq_26222859/article/details/53173692)

1. JavaScript中Object对象原型上的hasOwnProperty()用来判断一个属性是定义在对象本身而不是继承自原型链。
2. obj[key]

```js
var obj={a:1};
function (key){
    if(obj[key]){
        // 这个判断的key不是看obj有没有键，
        // 而是obj里面有没有对应的key
        // 因为obj[key] ==obj['a']
    }
}('a')
```

### css处理文字隐藏

```css
overflow: hidden;
/* overflow 属性规定当内容溢出元素框时发生的事情。这个属性定义溢出元素内容区的内容会如何处理。hidden 表示内容会被修剪，并且剪掉的内容是不可见的。 */

white-space: nowrap;
/* 规定文本不进行换行。white-space 属性设置如何处理元素内的空白。nowrap 表示文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。 */

text-overflow: ellipsis;
/* text-overflow 属性规定当文本溢出包含元素时发生的事情。ellipsis 表示显示省略符号来代表被修剪的文本。 */

width:50px;
/* width 属性设置div的长度。 */

word-break: break-all;
/* 表示文本长度超过就自动换行 */


// 多行文字溢出 有时候不生效是因为webpack 打包的时候把-webkit-box-orient: vertical这一行注释了
// 下面写法可以
 	overflow:hidden; 
  text-overflow:ellipsis;
  display:-webkit-box;
  /* autoprefixer: off */
  -webkit-box-orient:vertical;
  /* autoprefixer: on */
  -webkit-line-clamp:2; 
//或者
@mixin hide-line($line: 2) {
    display: -webkit-box;
    /* autoprefixer: ignore next */
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    text-overflow: ellipsis;
    overflow: hidden;
}
```

### 原生H5交互

```js
<script src="../Instruction/js/WebViewJavascriptBridge.js"></script>
// 注册
    // h5给安卓注册方法
    window.WebViewJavascriptBridge.registerHandler("userToken", function (data) {
        appToken = eval('(' + data + ')');
        $(".j-token").attr("data-token", appToken.usertoken);
        // $("#stitle").append(appToken.usertoken);
        cookie = appToken.usertoken;
        userId = appToken.userId;
        getInfos();
    });
    // h5给ios注册方法
    function userToken(data) {
        appToken = eval('(' + data + ')');
        $(".j-token").attr("data-token", appToken.usertoken);
        // $("#stitle").append(appToken.usertoken);
        cookie = appToken.usertoken;
        userId = appToken.userId;
        getInfos();
    }
// 调用
    // h5调用原生方法
    $('#deposit-free').on('click', function () {
        var u = navigator.userAgent, app = navigator.appVersion;
        if (u.indexOf('Android') > -1 || u.indexOf('Linux') > -1) {
            window.WebViewJavascriptBridge.callHandler(
                'freeToNative'
                ,{data}
                , function (responseData) { }
            );
        } else {
            window.webkit.messageHandlers.freeToNative.postMessage({});
        }
    })

```

# for循环中break、continue、return的区别

continue：结束本次循环，执行下一次循环

break：结束本循环体，执行后面的语句

return：结束当前函数，并使函数有返回值

这些只针对for循环，其他循环都各有特性，需要详查。

#### 思考：
- 为什么复杂类型要用堆内存存储
  
    > 答：栈内存是静态分配空间，在定义简单数据时就已经确认了占用内存大小；堆是动态分配空间，会根据复杂数据类型动态扩容
- 复杂类型是把值存储到堆内存中了还是把地址存到堆内存了
  
    > 答：复杂类型的值放在对内容中，把地址存在了栈内存中，当赋值给另一个变量的时候是把栈内存中的地址传递过去了
- for循环的执行原理
    - for循环有一个特别之处，就是设置循环变量的那一部分是一个父块儿级作用域，而循环体内部是一个单独的子块儿级作用域
    > https://www.cnblogs.com/echolun/p/10584703.html

- 变量提升
    + js分为编译阶段和执行阶段，编译阶段会把当前作用域的所有变量声明提升到作用域的顶部，然后去执行
    + 字面量函数表达式和变量的提升没有区别，此时函数只是一个值
    + 函数声明式会把整个函数提升到作用域的顶部，且函数声明不会被同名的变量声明覆盖，但是会被同名的变量赋值覆盖

        ```js
        console.log(a);
        console.log(a());
        var a = '我是变量赋值';
        function a(){
            console.log('我是函数声明，我最厉害了');
        }
        console.log(a);
        var a = function(){
            console.log('我就是个值')
        }
        console.log(a);

        // 编译阶段
        function a(){
            console.log('我是函数声明，我最厉害了');
        }
        var a;
        var a;
        console.log(a); // function a(){console.log('我是函数声明，我最厉害了')}
        console.log(a()); // 我是函数声明，我最厉害了
        a='我是变量赋值';
        console.log(a); // 我是变量赋值
        a=function(){
            console.log('我就是个值')
        }
        console.log(a); // function(){console.log('我就是个值')}
        ```

## 箭头函数

- 使用（）的情况

  ```js
  // 返回的是JSX表达式，只需要使用（）因为jsx语法规定只能有一个节点
  list.map(item=>(<WriterContentWrap>内容</WriterContentWrap>)
  // 等同于:
  list.map(item=>{return(<WriterContentWrap>内容</WriterContentWrap>)})
  ```

- 使用（{}）的情况

  ```js
  // 箭头后面返回的是一个对象时, 需要使用({});
  const mapState =  (state) => ({list: state.getIn(["home","WriterList"])});
  // 等同于:
  const mapState =  (state) => {return({list: state.getIn(["home","WriterList"])})};
  ```

- 什么括号都不用

  ```js
  // 箭头后面只有一条语句时, 可以直接将该条语句写在 =>后面
  (a,b)=>a+b;    
  // 等同于 
  (a,b) =>{return(num1 + num2)}
  ```


## 吸顶

## 上拉加载 下拉刷新

## 从url获取参数和给url拼参数

## tab切换筛选

## 图片预览

## 手指拖拽

请求的时候：判断**content-type**，如果**content-type**是form格式，那么传的数据格式

是key=value&key=value,如果**content-type**是非form格式，那么传的数据格式就是JSON字符串"{'a':'1','b':'2'}"

### 高阶函数

把函数作为参数或着返回值是函数的函数

常见的有sort、reduce函数

箭头函数柯里化

```js
// 柯里化理解不要去看函数的形式，理解是怎么样的结构
// 看本质：本质其实就是参数作用域的传递，最终返回的子函数可以使用所有父级的参数
add1 = a=>b=>c=>a+b+c;
add1 = a=>{
  return b=>{
    return c=>{
      return a+b+c;
    }
  }
}
add1(1)(2)(3);
add2 = (a,b,c)=>a+b+c;
// add1和add2最终一样，为什么要写成那样呢？
// 因为柯里化函数可以惰性执行和分批传参

```

reduce(function(acc, cur,idx,src))

为数组的每一项执行用户传入reduce的回调函数，回调函数接受4个参数（累计值，当前值，当前索引，源数组）;

### 对象的属性获取

```js
obj = {a:1,b:2,c:3}

obj.a =1; .右侧必须是一个以属性名称命名的简单标识符，不可以是数字

obj['a']= 1;  方括号内必须是一个计算结果为`字符串或数字`的表达式

Object.keys(obj) = ['a','b','c']; 返回给定对象的所有`可枚举`属性的`字符串`数组。
```

### [长列表渲染优化](https://zhuanlan.zhihu.com/p/41237949)

为什么有的URL需要解码？

## 拖拽

[两种方法实现](file:///Users/wangjing/Documents/learn/tuozhuai.html)

### 鼠标跟随事件





### H5的拖拽API

若要拖放某个元素，则必须将其的`draggable`属性设置为`true`。**`img`和`a`元素默认为`true`。**

拖放的过程中被拖放的对象被称为**源对象**，过拖放过程中间经过的其他对象被称为**过程对象**，最终到达的对象称作**目标对象**。

拖放事件可以用这三种对象来分类，不同的事件会被哪一种对象触发。

- 源对象：
  - `dragstart`：源对象开始拖放，开始移动时事件触发
  - `drag`：源对象拖放过程中，移动被拖拽对象时触发
  - `dragend`：源对象拖放结束，整个拖放操作结束时触发。
- 过程对象：
  - `dragenter`：源对象进入过程对象范围内，被拖拽对象进入过程对象时被触发
  - `dragover`：源对象在过程对象范围内移动，被拖拽对象在过程对象内移动时触发
  - `dragleave`：源对象离开过程对象的范围，被拖拽对象离开目标对象时触发
- 目标对象：
  - `drop`：源对象拖放到目标对象中，目标对象完全接受被拖拽对象时触发，可理解为在目标对象内松手时触发。

#### dataTransfer对象

在所有的拖放事件中都提供了一个数据传输对象`dataTransfer`，主要是用于在源对象和目标对象之间传递数据。

##### 方法

- ```
  setData(format, data)
  ```

  - 设置拖拽事件中要传递的数据，`format`的参数为数据类型

  - 该方法向

    ```
    dataTransfer
    ```

    中对象中存入数据，接受两个参数，第一个表示要存入的数据类型，共有4种：

    - text/plain
    - text/html
    - text/xml
    - text/uri-list

  - 第二个参数为要存入的数据，例如：`event.dataTransfer.setData('text/plain', 'hello world')`

**注：如果给定类型的数据不存在，则将其添加到拖动数据存储的末尾，使得`dataTransfer.types`列表中的最后一个项目将是新类型。**

- `getData(format)`
  - 获得拖拽事件中传递的数据，`format`参数为数据类型
  - 该方法从`dataTransfer`对象中读取数据，参数为在`setData`方法中指定的数据类型，例如：`event.dataTransfer.getData('text/plain')`
- `clearData()`
  - 该方法清空`dataTransfer`对象中存储的数据，参数可选，为数据类型。若为空，则清空所有数据。
- `setDragImage(element,x,y)`
  - 该方法通过`img`元素来设置拖放图标
  - `element`表示拖拽时鼠标下面的图片（通常是image元素，也可以说canvas元素）
  - x、y分别指示相对于图片的横向和纵向偏移量，相对应鼠标指针。
- `files`属性
  - 返回被拖拽的文件列表，是一个`FileList`对象，有`length`属性，可通过下标访问。

## js基础原理

1、基于对象的动态的、弱类型脚本语言（描述型语言）

​	不同于java/C++等编译型语言，编译型语言在执行前会先通篇编译成字节码（机器码）然后执行

​	js是边编译边执行

## jS中的执行环境分为三类:

1. 全局环境：当JS引擎进入一个代码块时，如遇到`<script>xxx</script>`标签，就是进入一个全局执行环境
2. 函数环境：当一个函数被调用时，在函数内部就形成了一个函数执行环境
3. `eval()`：把字符串单做JS代码执行，不推荐使用

## webpack

`webpack`只能处理js模块，根据js模块儿的依赖关系进行静态分析，给每个模块儿分配一个静态id，通过id索引和访问模块儿。

当需要处理其他类型的文件时就需要使用`loader`进行转换了。

`plugins` 用来完成一些loader不能完成的工作

```js
// 这是一个简单的配置（入口、出口、用到的模块儿）
module.exports = {
    entry: "./runoob1.js",
    output: {
        path: __dirname,
        filename: "bundle.js"
    },
    module: {
        loaders: [
            { test: /\.css$/, loader: "style-loader!css-loader" }
        ],
      	plugins:[
          new webpack.BannerPlugin('这个plugin用于在文件头部输出一些注释')
        ]
    }
};
```

### react 手写弹框怎么触发子组件的销毁

